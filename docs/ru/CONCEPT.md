<!-- Translation of docs/en/CONCEPT.md. May be outdated. -->

# Концепция: Локальный CI для разработки с агентами

## Цель

Главная цель локального CI в этом blueprint'е — **самопроверка под управлением агента**:

```
пишем код → запускаем CI → исправляем проблемы → повторяем → представляем результат
```

Это снижает потребность человека копипастить вывод компилятора/тестов в чат и обеспечивает плотный, автоматизированный цикл коррекции.

Локальный CI — это **движок исполнения** для этого цикла: он работает на машине разработчика, контролирует окружение и выдаёт структурированные результаты, которые агент может анализировать.

## Файлы инструкций для агента (например, `AGENTS.md`)

Многие репозитории содержат специальный файл инструкций для кодинг-агентов (часто называемый `AGENTS.md`).

Рекомендация: включите явную команду финальной верификации в этот файл, чтобы агент всегда запускал локальный CI перед отчётом о завершении.

Пример:

```ps
`./run.ps1 -SkipLaunch`
# или
`./run.ps1 -Fast -SkipLaunch`   # Если полный CI идет 5+ минут
```

Это снижает вероятность успешных ответов, которые никогда не были проверены CI.

## Философия дизайна

### 1. Fail Fast, Fail Loud (Падай быстро, падай громко)

CI должен останавливаться при первом критическом сбое. Не тратьте время на тесты, если код не компилируется.

```
fmt (fail) → STOP
fmt (ok) → lint (fail) → STOP
fmt (ok) → lint (ok) → test (fail) → STOP
```

### 2. Идемпотентность по умолчанию

Двойной запуск CI без изменений кода должен:
- Давать идентичные результаты
- Пропускать уже пройденные этапы (через кеширование)
- Не изменять рабочее дерево (если явно не запрошено)

### 3. Наблюдаемое выполнение

Длительные этапы должны предоставлять heartbeat-вывод ("пульс"), чтобы вы знали, что CI не завис:

```
[heartbeat] coverage alive t+00:02:15 last-out=3s line='test result: ok. 142 passed'
```

### 4. Оркестрация, независимая от языка

Оркестратору (`build.ps1`) всё равно, какой язык использует ваш проект. Его волнует только:
- Запуск этапов в нужном порядке
- Сбор статусов
- Управление кешами
- Создание отчётов

Логика, специфичная для языка, делегируется скриптам `build.<lang>`.

### 5. Профили для разных контекстов

Не каждому запуску нужен полный анализ покрытия или безопасности. Профили позволяют агенту выбирать правильный компромисс.

См.: [PROFILES.md](PROFILES.md).

Типичные намерения:
- `-Fast`: самопроверка агента / быстрая итерация
- (по умолчанию): перед пушем / валидация PR
- `-Security`: периодический аудит
- `-Release`: сборка артефактов

## Дисциплина вывода (Консоль vs Логи)

Локальный CI должен чётко подсвечивать проблемы, но избегать затопления консоли:
- Показывать проблемы инструментов.
    - Если вывод инструмента слишком длинный или проблем слишком много, печатайте только минимум и указывайте на лог-файл. Например, скрывайте проблемы после 240 символов (число подбирается под специфику проекта).
- Показывать компактную сводку в конце прогона с короткими заметками.

Это сохраняет цикл агента эффективным и не забивает контекст чата шумом.

## Логи Enforcer и улучшение процесса

Этот blueprint использует два постоянных лог-файла:
- `Enforcer_last_check.log`: машиночитаемый снимок последнего запуска (перезаписывается при каждом запуске)
- `Enforcer_stats.log`: append-only история для анализа трендов

**Важно**: `Enforcer_stats.log` — это не "просто лог". Он предназначен для еженедельного/ежемесячного обзора, чтобы ответить на вопросы:
- Какие ошибки случаются чаще всего?
- Стоит ли подстроить правила (сделать строже/мягче)?
- Нужно ли скорректировать промптинг/воркфлоу агента, чтобы предотвратить повторяющиеся классы ошибок?

> Если вы работаете в команде, разработайте механизмы для сбора логов в единое хранилище или даже общий лог-файл.

**Политика хранения**:
- Не удаляйте `Enforcer_stats.log` автоматически по времени.
- Очистка происходит только вручную, после обзора и изменений процесса.

## Что даёт этот Blueprint

1. **Архитектурные паттерны** — Как структурировать ваши CI скрипты
2. **Контракты этапов** — Что каждый этап должен делать и возвращать
3. **Стратегии кеширования** — Как пропускать лишнюю работу
4. **Обнаружение зависаний** — Как ловить застрявшие процессы
5. **Формат отчёта** — Как структурировать вывод CI для инструментов

## Чего этот Blueprint НЕ даёт

- Готовых к запуску скриптов (адаптируйте под свой проект)
- Конфигураций инструментов под конкретный язык (используйте свои линтеры)
- Интеграции с облачным CI (это отдельная задача)

## Терминология

| Термин | Значение |
|--------|----------|
| **Runner** | Скрипт точки входа пользователя/агента (`run.ps1`) |
| **Builder** | Главный скрипт, запускающий этапы по порядку (`build.ps1`) |
| **Stage** | Один шаг CI (например, `fmt`, `lint`, `test`) |
| **Profile** / **Flag** | Предопределенный набор этапов для конкретного сценария |
| **Trust stamp** | Файл, указывающий, что этап был ранее успешен |
| **Hash guard** | Инвалидация кеша на основе хешей исходных файлов |
| **Heartbeat** | Периодический вывод во время долгих этапов, с завершением при зависании |

## Общие флаги (Примеры)

Точные флаги зависят от проекта, но типичные паттерны включают:
- `-Fast`: пропуск дорогих этапов, фокус на быстрой обратной связи
- `-Release`: сборка артефактов
- `-Skip<Stage>`: тонкий контроль этапов (напр., `-SkipLaunch`, `-SkipCoverage`)
