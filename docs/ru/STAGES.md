<!-- Translation of docs/en/STAGES.md. May be outdated. -->

# Этапы: Определения и Контракты

## Семантика статусов этапов

Каждый этап должен выдавать ровно один из этих статусов:

| Статус | Значение | Поведение пайплайна | Код выхода |
|--------|----------|---------------------|------------|
| `ok` | Этап завершен успешно | Продолжить к следующему этапу | 0 |
| `warn` | Этап завершен с некритичными проблемами | Продолжить к следующему этапу | 0 |
| `fail` | Этап провален с критическими ошибками | Остановить пайплайн (настраиваемо) | 1 |
| `cached` | Этап пропущен из-за попадания в кеш | Продолжить к следующему этапу | 0 |
| `skip` | Этап пропущен (флаги / профиль / не применимо) | Продолжить к следующему этапу | 0 |

## Стандартные этапы

### 0. CI Self-Check (`self-check`)

**Назначение**: Валидация самого CI (скрипты runner/orchestrator, конфиги, связующий код) перед запуском проверок на целевом проекте.

Этот этап предотвращает трату времени цикла агента на сломанные "леса" CI:

```
write CI → run CI → CI fails (self-check) → fix CI → run again
```

**Что валидировать (примеры)**:
- Синтаксис скриптов Runner и Builder (быстрая диагностика парсера)
- Линтинг скриптов CI (стиль + корректность)
- Базовые инварианты: необходимые файлы существуют, нужные инструменты обнаруживаются, конфиги парсятся
- `tools/*.ps1`

**Идеи инструментов**:
- PowerShell:
  - Parser diagnostics (`System.Management.Automation.Language.Parser`)
  - PSScriptAnalyzer (с опциональным файлом настроек)
- Bash: `shellcheck`
- Makefiles: базовый `make -n` / инструменты линтинга
- Конфиги CI: валидация JSON/YAML схемы (если применимо)

**Маппинг статусов**:
- `ok`: Скрипты/конфиги CI валидны
- `warn`: Некритичные проблемы CI (предупреждения стиля), которые стоит исправить
- `fail`: CI невалиден (ошибки парсинга, критические ошибки линтинга)
- `cached`: Cache hit
- `skip`: Отключено флагом / профилем / не применимо

> CI — это критическая часть вашего продукта, поэтому я рекомендую FAIL даже на WARN.

### 1. Format (`fmt`)

**Назначение**: Обеспечение единого стиля кода.

**Инструменты по языкам**:
- Python: `ruff format`, `black`
- Rust: `cargo fmt`
- TypeScript: `prettier`, `eslint --fix`
- Go: `gofmt`

**Поведение**:
- Режим проверки (Check mode): Проверить форматирование без изменений
- Режим исправления (Fix mode): Авто-исправление проблем

**Маппинг статусов**:
- `ok`: Код отформатирован правильно
- `fail`: Код имеет проблемы форматирования (check mode)
- `cached`: Cache hit
- `skip`: Отключено флагом / профилем / не применимо

```
# Pseudocode contract
Input:  Source files
Output: Status (ok|fail|cached|skip)
Effect: None (check) or Modified files (fix)
```

### 2. Lint (`lint`)

**Назначение**: Поиск проблем качества кода, нарушений стиля, потенциальных багов.

**Инструменты по языкам**:
- Python: `ruff check`, `flake8`, `pylint`
- Rust: `cargo clippy`
- TypeScript: `eslint`
- Go: `golangci-lint`

**Поведение**:
- Отчёт о проблемах с указанием file:line:column
- Опционально авто-исправление безопасных проблем

**Маппинг статусов**:
- `ok`: Проблем не найдено
- `warn`: Только некритичные проблемы (напр., предложения по стилю)
- `fail`: Найдены критические проблемы
- `cached`: Cache hit
- `skip`: Отключено флагом / профилем / не применимо

### 3. Policy: Line Limits (`line-limits`)

**Назначение**: Предотвращение появления "god files" и переразмеренных директорий, которые сложно поддерживать (и людям, и LLM).

Этот этап намеренно независим от языка и может быть реализован как:
- Небольшой скомпилированный хелпер (`tools/ci/line-limits`)
- Скрипт (`tools/ci/line_limits.py`)
- Нативный инструмент языка (если есть)

**Что проверять (примеры)**:
- Макс. строк исполняемого кода для файлов (пороги warn/fail)
- Макс. файлов в директории (пороги warn/fail)
- Короткий список "топ нарушителей" для консольной сводки

**Маппинг статусов**:
- `ok`: Лимиты не превышены
- `warn`: Превышен хотя бы один warn-порог (не блокирует)
- `fail`: Превышен хотя бы один fail-порог (блокирует)
- `cached`: Cache hit
- `skip`: Отключено флагом / профилем / не применимо

**Пороги (пример)**:

```
warn_threshold_lines = 1500
fail_threshold_lines = 2500

max_files_per_dir_warn = 20
max_files_per_dir_fail = 50
```

**Совет по выводу в консоль**:
- Печатайте только топ несколько нарушителей.
- Всегда пишите полные детали в лог-файл и ссылайтесь на него из сводки.

### 4. Compile / Type Check (`compile`)

**Назначение**: Верификация того, что код компилируется и проходит проверку типов.

Примечание: в некоторых экосистемах `compile` и `build` — это фактически одна команда.
В таком случае допустимо:
- слить `compile` в `build`, или
- трактовать `compile` как "быструю сборку" (напр., `cargo check`, `tsc --noEmit`), а `build` как "сборку артефактов" (напр., `cargo build --release`).

**Инструменты по языкам**:
- Python: `mypy`, `pyright`, `python -m compileall`
- Rust: `cargo check` / `cargo build`
- TypeScript: `tsc --noEmit`
- Go: `go build`

**Маппинг статусов**:
- `ok`: Код компилируется без ошибок
- `warn`: Компилируется с предупреждениями (если они не фатальны)
- `fail`: Ошибки компиляции
- `cached`: Cache hit
- `skip`: Отключено флагом / профилем / не применимо

### 5. Test (`test`)

**Назначение**: Запуск автоматических тестов.

**Инструменты по языкам**:
- Python: `pytest`
- Rust: `cargo test`
- TypeScript: `vitest`, `jest`
- Go: `go test`

**Поведение**:
- Запуск тестового набора
- Отчёт о кол-ве pass/fail
- Опционально fail fast при первой ошибке

**Маппинг статусов**:
- `ok`: Все тесты прошли
- `warn`: Тесты прошли, но с предупреждениями (напр., медленные тесты)
- `fail`: Один или более тестов упали
- `cached`: Cache hit (опционально)
- `skip`: Отключено флагом / профилем / не применимо

### 6. Coverage (`coverage`)

**Назначение**: Измерение тестового покрытия и обеспечение порогов.

**Инструменты по языкам**:
- Python: `pytest-cov`, `coverage.py`
- Rust: `cargo llvm-cov`, `tarpaulin`
- TypeScript: `vitest --coverage`, `c8`
- Go: `go test -cover`

**Поведение**:
- Сбор данных покрытия во время прогона тестов
- Отчёт о процентах покрытия
- Опционально fail, если ниже порога

**Продвинуто: руководство по покрытию**

[Некоторые проекты](https://dtf.ru/indie/4685854-alfa-2-1-zavershenie-testirovaniya-i-uluchshenie-ci-sistemy) реализуют механизм "что тестировать дальше" ([CovRank](https://dtf.ru/indie/4571267-optimizatsiya-ci-i-testirovanie-v-alpha-2-proekta-living-layers)): вместо только лишь проверки порога, CI выдаёт ранжированный список целей с низким покрытием и высоким влиянием, чтобы направить агента к наиболее эффективным тестам.

Это намеренно оставлено за рамками этого blueprint'а.

**Маппинг статусов**:
- `ok`: Покрытие соответствует или выше порога
- `warn`: Покрытие ниже warn-порога, но выше fail-порога
- `fail`: Покрытие ниже fail-порога
- `cached`: Cache hit (опционально)
- `skip`: Отключено через `-Fast` или `-SkipCoverage`

**Пороги (пример)**:
```
warn_threshold = 75%
fail_threshold = 60%

coverage >= 75%  → ok
60% <= coverage < 75%  → warn
coverage < 60%  → fail
```

### 7. Security (`security`)

**Назначение**: Обнаружение уязвимостей безопасности.

**Инструменты по языкам**:
- Python: `bandit`, `pip-audit`
- Rust: `cargo audit`
- TypeScript: `npm audit`
- Go: `govulncheck`

**Поведение**:
- Сканирование на известные уязвимости
- Проверка зависимостей на CVE
- Отчёт об уровнях серьезности

**Маппинг статусов**:
- `ok`: Нет high/critical уязвимостей
- `warn`: Только low/medium проблемы
- `fail`: Найдены high/critical уязвимости
- `cached`: Cache hit (опционально)
- `skip`: Отключено или не применимо

### 8. Build (`build`)

**Назначение**: Создание распространяемых артефактов.

**Поведение**:
- Компиляция релизных бинарников
- Сборка ассетов
- Генерация метаданных версий

**Маппинг статусов**:
- `ok`: Сборка успешна
- `fail`: Сборка провалилась
- `cached`: Cache hit (опционально)
- `skip`: Не применимо (напр., библиотеки)

### 9. Archive (`archive`)

**Назначение**: Упаковка артефактов сборки для дистрибуции.

**Поведение**:
- Создание версионированного архива (zip, tar.gz)
- Включение бинарников, ассетов, документации
- Генерация контрольных сумм

**Маппинг статусов**:
- `ok`: Архив создан успешно
- `fail`: Создание архива провалилось
- `cached`: Cache hit (опционально)
- `skip`: `-SkipArchive` или этап build провалился

## Объект результата этапа

```json
{
  "name": "test",
  "status": "fail",
  "note": "3 tests failed",
  "duration_ms": 12500,
  "details": {
    "total": 142,
    "passed": 139,
    "failed": 3,
    "skipped": 0
  }
}
```

## Кастомные этапы

Проекты могут определять свои этапы, следуя тому же контракту:

Частые примеры:
- `e2e`: end-to-end или интеграционные тесты (часто медленнее, могут требовать локальной инфраструктуры)
- `launch`: запуск приложения после CI (интерактивная/ручная проверка; часто пропускается для автоматизации через `-SkipLaunch`)
- `workspace-policy`: общепроектные проверки политик (метаданные, соглашения, расположение файлов)
- `target-size`: размер артефакта сборки / контроль бюджета размера папок

```powershell
# Custom stage example: Database migrations
Invoke-Stage -Name "db-migrate" -Action {
    # Run migrations in check mode
    $result = & alembic check
    if ($LASTEXITCODE -ne 0) {
        throw "Pending migrations detected"
    }
}
```

## Конфигурация этапов

Этапы можно конфигурировать через `.ci/config.json`:

```json
{
  "stages": {
    "coverage": {
      "warn_threshold": 75,
      "fail_threshold": 60
    },
    "security": {
      "ignore_advisories": ["CVE-2023-XXXXX"]
    },
    "lint": {
      "disabled_rules": ["E501", "W503"]
    }
  }
}
```
